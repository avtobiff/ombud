OMBUD
=====

Ombud (Swedish for proxy) is a simple network proxy which takes commands
from connecting clients. The commands have the form "ADDRESS:PORT\r\n",
when Ombud recieves a command it connects to the given address and port,
reads whatever is sent, caches it on disk, and relays it back to the
client.


BUILD AND REQUIREMENTS
----------------------
You need to run Linux 3.9 or later, this is because SO_REUSEPORT.

In order to build, first install build dependencies

    sudo apt-get install build-essential libssl-dev

then build by executing

    make


RUN
---
Execute Ombud with

    make run

This will start Ombud on the default port 8090. The cache is created in
$PWD/cache-ombud.

NB! The cache is removed from source directory during invokations of
make clean.

It is possible to give port number as a command line argument

    bin/ombud 8077


DESIGN
------
The main function is in the connection handler, which handles client
connections and executing the client commands (connecting to services)
and caching/sending back the response. This is based on epoll(2), which
is Linux specific.

The connection handlers are forked into their own processes, one process
per CPU core, and the listen sockets are setup with SO_REUSEPORT. This
will enable all four processes to listen on the same listen socket, and
the kernel handles distribution of incoming requests. (It is stated that
SO_REUSEPORT will distribute incoming requests uniformly, which was
stated not to be the case with threaded acceptors. See Linux kernel
commit c617f39 for more information.)

When clients request data from address:port a cache lookup is performed.
On a cache hit the contents are sent to the client with sendfile(2). On
a cache miss Ombud connects to the given address and port, reads the
data, writes it to the cache, and finally relays it back to the client.


ASSUMPTIONS
-----------
* Only IPv4, this application knows little to nothing about IPv6.

* Well formed client commands and connectable services are assumed,
  malformed requests and unconnectable hosts are silently dropped.

* Not a lot of data will be sent from the services that Ombud connects
  to, a static buffer size of 8 kB is deemed to be adequate for the use
  case.

* Data downloaded from hosts are assumed to never change, hence the
  content in the cache never expires.


DISADVANTAGES
-------------
* Using select(2) doesn't scale that well, being O(fd_max), where fd_max
  is the largest file descriptor.


POSSIBLE IMPROVEMENTS
---------------------
* Using epoll(2) or libevent instead. Epoll scales a lot better, O(1),
  with many file descriptors.

* Given time I would have tried libuv, it looks interesting.

* In order to make a more efficient cache hostnames could be resolved to
  ip addresses before they are used as part of the key.

* Linking against OpenSSL. If the code is going to be release under the
  GPL an OpenSSL linking exception is required in the license in order
  to be specific about the user's rights and responsibilities. It would
  of course be possible to use libgcrypt in this case instead,
  especially since we only use SHA1() because it is simple.

* Make cache directory and listen port configurable from the command
  line with getopt and possibly through a configuration file.

* Since this is a simple server it might be enough to store the cache in
  memory. Alternatively, store it in a ramdisk.

* More robust error handling, e.g. cache storage breaks between succesful
  lookup and send.

* Of course the standard things: more documentation, configuration file,
  command line options instead of hard coded values etc.

* Thread safe cache, it is now quite possible to botch it with race conditions
  etc.

* Toggable DEBUG prints...
